# Regras de Arquitetura Android (Clean Architecture & MVVM)

Estas regras definem o padrão de desenvolvimento para aplicações Android Kotlin, baseadas em Clean Architecture, MVVM e Jetpack Compose. O objetivo é garantir escalabilidade, testabilidade e "Screaming Architecture".

## 1. Estrutura do Projeto (Camadas)

O código deve ser estritamente separado em três camadas. Não misturar responsabilidades.

### A. Domain Layer (Camada de Domínio)
- **Localização:** `domain/`
- **Responsabilidade:** Lógica de negócio pura.
- **Conteúdo:** Use Cases, Modelos de Domínio, Interfaces de Repositório.
- **Regra:** Deve ser **Kotlin puro**. Não deve conter imports do Android, Retrofit, Firebase ou bibliotecas de UI.

### B. Data Layer (Camada de Dados)
- **Localização:** `data/`
- **Responsabilidade:** Recuperação e persistência de dados.
- **Conteúdo:** Implementações de Repositório, APIs (Retrofit), DTOs, Base de Dados (Room), Entities Firebase.
- **Regra:** Contém as dependências de framework e serialização. DTOs nunca saem desta camada.

### C. Presentation Layer (Camada de Apresentação)
- **Localização:** `ui/`
- **Responsabilidade:** UI e gestão de estado de ecrã.
- **Conteúdo:** Activities, Composables, ViewModels.
- **Regra:** Esta camada depende da camada de Domain, mas nunca da camada de Data diretamente.

## 2. Padrões de Fluxo de Dados

### Data Transfer Objects (DTOs) vs. Domain Models

1. **DTOs (`data/remote/dto/`):**
   - Criar data classes que espelham exatamente a resposta da API (com anotações `@SerializedName` se necessário).
   - DTOs nunca saem da camada `data`.

2. **Domain Models (`domain/model/`):**
   - Criar data classes limpas contendo apenas os dados que a app realmente utiliza.
   - Kotlin puro, sem anotações de framework.

3. **Mappers:**
   - Criar funções de extensão (ex: `fun ItemDto.toItem(): Item`) dentro do ficheiro DTO para converter o DTO no Modelo de Domínio.

## 3. Business Logic: Use Cases

Toda a lógica de negócio deve ser encapsulada em **Use Cases**.

- **Nomenclatura:** `Verbo` + `Substantivo` + `UseCase` (ex: `GetUserDataUseCase`, `SearchMediaUseCase`).
- **Localização:** `domain/usecase/`

- **Estrutura:**
  - Cada Use Case deve ter uma única responsabilidade pública.
  - Sobrescrever o operador `operator fun invoke()`. Isso permite chamar a classe como uma função.

- **Retorno:**
  - Operações assíncronas devem retornar `Flow<Resource<T>>`.
  - O fluxo deve emitir sequencialmente: `Resource.Loading` -> `Resource.Success` (com dados) ou `Resource.Error`.

- **Tratamento de Erros:**
  - Utilizar blocos `try/catch` dentro do Use Case para capturar:
    - `HttpException` (erros de API)
    - `IOException` (erros de rede/internet)
  - Emitir `Resource.Error` com mensagens apropriadas em português.

```kotlin
class SearchMediaUseCase @Inject constructor(
    private val mediaRepository: MediaRepository
) {
    operator fun invoke(query: String): Flow<Resource<SearchResult>> = flow {
        emit(Resource.Loading())
        try {
            val result = mediaRepository.searchMulti(query)
            emit(Resource.Success(result))
        } catch (e: HttpException) {
            emit(Resource.Error("Erro de servidor: ${e.code()}"))
        } catch (e: IOException) {
            emit(Resource.Error("Verifique a sua ligação à internet"))
        }
    }
}
```

## 4. State Management (ViewModel)

- **Injeção:** O ViewModel deve injetar **Use Cases**, nunca Repositórios diretamente.
- **State Holder:** Criar uma data class única para representar o estado do ecrã (ex: `ScreenUiState`), contendo propriedades como `isLoading: Boolean`, `data: T?`, `errorMessage: String?`.
- **Imutabilidade:** Expor o estado como `StateFlow<T>` (imutável) para o Compose, mantendo o `MutableStateFlow<T>` privado.
- **Processamento:** Ao chamar o Use Case, utilizar `.onEach` para reagir às emissões do `Resource` e atualizar o estado, com `.launchIn(viewModelScope)`.

```kotlin
@HiltViewModel
class SearchViewModel @Inject constructor(
    private val searchMediaUseCase: SearchMediaUseCase
) : ViewModel() {

    private val _uiState = MutableStateFlow(SearchUiState())
    val uiState: StateFlow<SearchUiState> = _uiState.asStateFlow()

    fun search(query: String) {
        searchMediaUseCase(query)
            .onEach { result ->
                _uiState.value = when (result) {
                    is Resource.Loading -> _uiState.value.copy(isLoading = true)
                    is Resource.Success -> _uiState.value.copy(
                        isLoading = false,
                        results = result.data
                    )
                    is Resource.Error -> _uiState.value.copy(
                        isLoading = false,
                        errorMessage = result.message
                    )
                }
            }
            .launchIn(viewModelScope)
    }
}
```

## 5. Repository Pattern

- **Interfaces (`domain/repository/`):**
  - Definir interfaces no Domain Layer.
  - Métodos devem usar tipos do Domain, nunca DTOs.

- **Implementações (`data/repository/`):**
  - Implementar as interfaces do Domain.
  - Fazer a conversão DTO → Domain Model internamente.
  - Adicionar lógica de cache se necessário.

## 6. Injeção de Dependência (Dagger Hilt)

- **Módulos (`di/`):**
  - Usar `@Provides` e `@Singleton` para instâncias únicas.
  - Para Repositórios: Usar `@Binds` - a função deve declarar retorno da **Interface** (Domain), vinculando à **Implementação** (Data).

```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {

    @Binds
    @Singleton
    abstract fun bindMediaRepository(
        impl: MediaRepositoryImpl
    ): MediaRepository
}
```

## 7. Classe Utilitária (Resource)

Utilizar sempre esta wrapper para comunicação entre camadas:

```kotlin
sealed class Resource<T>(val data: T? = null, val message: String? = null) {
    class Success<T>(data: T) : Resource<T>(data)
    class Error<T>(message: String, data: T? = null) : Resource<T>(data, message)
    class Loading<T>(data: T? = null) : Resource<T>(data)
}
```

## 8. Estrutura de Pastas Padrão

```
app/src/main/java/com/example/app/
├── domain/
│   ├── model/           # Modelos de domínio (Kotlin puro)
│   ├── repository/      # Interfaces de repositório
│   └── usecase/         # Use Cases
├── data/
│   ├── remote/
│   │   ├── api/         # Retrofit services
│   │   └── dto/         # DTOs + Mappers
│   ├── local/
│   │   ├── dao/         # Room DAOs
│   │   └── entity/      # Room Entities
│   └── repository/      # Implementações de repositório
├── di/                  # Módulos Hilt
├── ui/
│   ├── navigation/      # Navegação
│   ├── screens/         # Ecrãs (Composable + ViewModel)
│   └── theme/           # Material Theme
└── util/                # Utilidades (Resource, Constants, Extensions)
```

## 9. README.md Padrão

Todo projeto deve ter README.md com:
1. Header com logo + badges (Android, Kotlin, Compose, etc.)
2. Descrição do projeto
3. Funcionalidades (lista com emojis)
4. Screenshots
5. Tecnologias (tabela)
6. Arquitetura (diagrama de pastas + explicação das camadas)
7. Configuração e instalação
8. Autor e licença

## 10. Projeto Modelo

**Tagline** (https://github.com/ricardoguimaraes2021/tagline) é o projeto de referência que implementa todas estas regras corretamente. Usar como modelo para novos projetos ou refatorações.

